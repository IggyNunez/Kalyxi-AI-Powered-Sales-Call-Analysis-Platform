#!/usr/bin/env npx tsx
/**
 * Kalyxi AI - Master Test Runner
 *
 * Runs all test suites and generates a comprehensive report.
 *
 * Usage:
 *   npx tsx tests/run-all-tests.ts           # Run all tests
 *   npx tsx tests/run-all-tests.ts --seed    # Seed data first, then run tests
 *   npx tsx tests/run-all-tests.ts --quick   # Run quick subset of tests
 *
 * Phases:
 *   1. Seed data (if --seed flag)
 *   2. Database constraint tests
 *   3. RLS attack tests
 *   4. API integration tests
 *   5. AI pipeline tests
 *   6. Storage security tests
 *   7. Generate report
 */

import { spawn, SpawnOptions } from "child_process";
import * as fs from "fs";
import * as path from "path";

interface TestSuiteResult {
  name: string;
  passed: boolean;
  exitCode: number;
  duration: number;
  output: string;
}

const testSuites = [
  {
    name: "Deterministic Seed",
    script: "tests/seed/deterministic-seed.ts",
    required: true,
    runWithSeed: true,
    runWithQuick: true,
  },
  {
    name: "Database Constraints",
    script: "tests/db/constraint-tests.ts",
    required: true,
    runWithSeed: false,
    runWithQuick: true,
  },
  {
    name: "RLS Attack Suite",
    script: "tests/rls/comprehensive-rls-tests.ts",
    required: true,
    runWithSeed: false,
    runWithQuick: true,
  },
  {
    name: "API Integration",
    script: "tests/api/comprehensive-api-tests.ts",
    required: true,
    runWithSeed: false,
    runWithQuick: false,
  },
  {
    name: "AI Pipeline",
    script: "tests/ai/ai-pipeline-tests.ts",
    required: false,
    runWithSeed: false,
    runWithQuick: false,
  },
  {
    name: "Storage Security",
    script: "tests/storage/storage-security-tests.ts",
    required: false,
    runWithSeed: false,
    runWithQuick: false,
  },
];

async function runTest(
  name: string,
  script: string
): Promise<TestSuiteResult> {
  const startTime = Date.now();
  let output = "";

  return new Promise((resolve) => {
    const options: SpawnOptions = {
      cwd: process.cwd(),
      shell: true,
      env: { ...process.env },
    };

    const child = spawn("npx", ["tsx", script], options);

    child.stdout?.on("data", (data: Buffer) => {
      const text = data.toString();
      output += text;
      process.stdout.write(text);
    });

    child.stderr?.on("data", (data: Buffer) => {
      const text = data.toString();
      output += text;
      process.stderr.write(text);
    });

    child.on("close", (code) => {
      resolve({
        name,
        passed: code === 0,
        exitCode: code || 0,
        duration: Date.now() - startTime,
        output,
      });
    });

    child.on("error", (error) => {
      resolve({
        name,
        passed: false,
        exitCode: 1,
        duration: Date.now() - startTime,
        output: output + `\nError: ${error.message}`,
      });
    });
  });
}

function generateReport(results: TestSuiteResult[]): string {
  const timestamp = new Date().toISOString();
  const totalDuration = results.reduce((sum, r) => sum + r.duration, 0);
  const passed = results.filter((r) => r.passed).length;
  const failed = results.filter((r) => !r.passed).length;

  let report = `# KALYXI AI - FULL SYSTEM AUDIT REPORT

Generated: ${timestamp}

## Summary

| Metric | Value |
|--------|-------|
| Total Suites | ${results.length} |
| Passed | ${passed} |
| Failed | ${failed} |
| Total Duration | ${Math.round(totalDuration / 1000)}s |

## Results by Suite

`;

  for (const result of results) {
    const status = result.passed ? "PASS" : "FAIL";
    const icon = result.passed ? "‚úÖ" : "‚ùå";

    report += `### ${icon} ${result.name}

- **Status**: ${status}
- **Exit Code**: ${result.exitCode}
- **Duration**: ${Math.round(result.duration / 1000)}s

`;

    if (!result.passed) {
      report += `<details>
<summary>View Output</summary>

\`\`\`
${result.output.substring(0, 5000)}${result.output.length > 5000 ? "\n... (truncated)" : ""}
\`\`\`

</details>

`;
    }
  }

  // Add recommendations
  report += `## Recommendations

`;

  const failedSuites = results.filter((r) => !r.passed);
  if (failedSuites.length > 0) {
    report += `### Critical Issues to Address

`;
    for (const suite of failedSuites) {
      report += `- **${suite.name}**: Review output above and fix identified issues\n`;
    }
    report += `
`;
  }

  report += `### Next Steps

1. Review any failed tests and fix the underlying issues
2. Re-run the test suite to verify fixes
3. Consider adding E2E tests with Playwright for UI coverage
4. Set up CI/CD to run these tests on every PR

---

*Report generated by Kalyxi AI Test Suite*
`;

  return report;
}

async function main() {
  const args = process.argv.slice(2);
  const seedFirst = args.includes("--seed");
  const quickMode = args.includes("--quick");

  console.log("=".repeat(60));
  console.log("KALYXI AI - FULL SYSTEM AUDIT");
  console.log("=".repeat(60));
  console.log("");
  console.log(`Mode: ${quickMode ? "Quick" : "Full"}`);
  console.log(`Seed first: ${seedFirst}`);
  console.log("");

  const results: TestSuiteResult[] = [];
  const startTime = Date.now();

  // Determine which suites to run
  let suitesToRun = testSuites;

  if (quickMode) {
    suitesToRun = testSuites.filter((s) => s.runWithQuick);
  }

  if (!seedFirst) {
    suitesToRun = suitesToRun.filter((s) => !s.runWithSeed);
  }

  console.log(`Running ${suitesToRun.length} test suites:\n`);
  suitesToRun.forEach((s, i) => console.log(`  ${i + 1}. ${s.name}`));
  console.log("");

  // Run each test suite
  for (const suite of suitesToRun) {
    console.log("\n" + "=".repeat(60));
    console.log(`RUNNING: ${suite.name}`);
    console.log("=".repeat(60) + "\n");

    const result = await runTest(suite.name, suite.script);
    results.push(result);

    // Stop on required suite failure
    if (suite.required && !result.passed) {
      console.log(`\n‚ùå Required suite "${suite.name}" failed. Stopping execution.`);
      break;
    }
  }

  // Generate report
  const report = generateReport(results);
  const reportPath = path.join(process.cwd(), "tests", "AUDIT_REPORT.md");
  fs.writeFileSync(reportPath, report);

  // Print summary
  console.log("\n" + "=".repeat(60));
  console.log("AUDIT COMPLETE");
  console.log("=".repeat(60));

  const passed = results.filter((r) => r.passed).length;
  const failed = results.filter((r) => !r.passed).length;
  const totalDuration = Date.now() - startTime;

  console.log(`\nTotal Duration: ${Math.round(totalDuration / 1000)}s`);
  console.log(`Suites Passed: ${passed}/${results.length}`);
  console.log(`Suites Failed: ${failed}/${results.length}`);
  console.log(`\nReport saved to: ${reportPath}`);

  // Print failed suites
  const failedSuites = results.filter((r) => !r.passed);
  if (failedSuites.length > 0) {
    console.log("\n‚ùå Failed Suites:");
    failedSuites.forEach((s) => console.log(`  - ${s.name}`));
  }

  // Exit with appropriate code
  const hasBlockers = failedSuites.some((s) =>
    testSuites.find((ts) => ts.name === s.name)?.required
  );

  if (hasBlockers) {
    console.log("\nüö® BLOCKER ISSUES FOUND - Cannot deploy to production");
    process.exit(2);
  } else if (failed > 0) {
    console.log("\n‚ö†Ô∏è  Issues found - Review before deploying");
    process.exit(1);
  } else {
    console.log("\n‚úÖ All tests passed!");
    process.exit(0);
  }
}

main().catch((error) => {
  console.error("Fatal error:", error);
  process.exit(1);
});
